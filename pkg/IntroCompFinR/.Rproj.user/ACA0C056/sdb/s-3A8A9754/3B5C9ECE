{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Portfolio Theory with No-Short Sales\"\nauthor: \"Eric Zivot\"\ndate: \"August 21, 2016\"\noutput: slidy_presentation\n---\n\n## Set options and load packages\n\n```{r}\noptions(digits=3, width=70)\n# install IntroCompFinR package from R-forge\n# use install.packages(\"IntroCompFinR\", repos=\"http://R-Forge.R-project.org\")\nlibrary(quadprog)\nlibrary(IntroCompFinR)\nlibrary(PerformanceAnalytics)\nlibrary(zoo)\nSys.setenv(TZ=\"UTC\")\ncex.val = 2\n```\n\n## Two risky asset example data\n\n```{r}\nmu.A = 0.175\nsig.A = 0.258\nsig2.A = sig.A^2\nmu.B = 0.055\nsig.B = 0.115\nsig2.B = sig.B^2\nrho.AB = -0.164\nsig.AB = rho.AB*sig.A*sig.B\nr.f = 0.03\n```\n\nMatrix algebra variables\n\n```{r}\nassetNames = c(\"Asset A\", \"Asset B\")\nmu.vals = c(mu.A, mu.B)\nnames(mu.vals) = assetNames\nSigma = matrix(c(sig2.A, sig.AB, sig.AB, sig2.B), 2, 2)\ncolnames(Sigma) = rownames(Sigma) = assetNames\n```\n\n## Two risky asset portfolio frontier\n\nPortfolios of assets A and B:\n\n```{r}\n# create portfolios for frontier plot\nx.A = seq(from=-0.4, to=1.4, by=0.1)\nx.B = 1 - x.A\nn.port = length(x.A)\nnames(x.A) = names(x.B) = paste(\"p\", 1:n.port, sep=\".\")\nmu.p = x.A*mu.A + x.B*mu.B\nsig2.p = x.A^2 * sig2.A + x.B^2 * sig2.B + 2*x.A*x.B*sig.AB\nsig.p = sqrt(sig2.p)\n\n```\n\n\n```{r, echo=FALSE}\ncex.val = 2\nplot(sig.p, mu.p, type=\"b\", pch=16, cex = cex.val,\n     ylim=c(0, max(mu.p)), xlim=c(0, max(sig.p)),\n     xlab=expression(sigma[p]), ylab=expression(mu[p]), cex.lab=cex.val,\n     col=c(rep(\"lightblue\", 4), rep(\"black\", 11), rep(\"lightblue\", 4)))\ntext(x=sig.A, y=mu.A, labels=\"Asset A\", pos=4, cex = cex.val)\ntext(x=sig.B, y=mu.B, labels=\"Asset B\", pos=4, cex = cex.val)\n\n```\n\nThe long-only portfolios (black dots) are:\n\n```{r}\nlongOnly = rbind(x.A[5:15], x.B[5:15])\nrownames(longOnly) = assetNames\nlongOnly\n```\n\nThe long-short portfolios (blue dots) are:\n\n```{r}\nlongShort = rbind(x.A[c(1:4, 16:19)], x.B[c(1:4, 16:19)])\nrownames(longShort) = assetNames\nlongShort\n```\n\n## Global minimum variance portfolios\n\nUnconstrained global minimum variance portfolio\n\n```{r}\ngmin.port = globalMin.portfolio(mu.vals, Sigma)\ngmin.port\n```\n\nCut-off value of $rho_{AB}$ for which $x_{A}$ become negative:\n\n```{r}\nsig.B/sig.A\n```\n\nCompute global minimum variance portfolio for $rho_{AB} = 0.8$\n```{r}\nrho.AB = 0.8\nsig.AB = rho.AB*sig.A*sig.B\nSigma = matrix(c(sig2.A, sig.AB, sig.AB, sig2.B), 2, 2)\ngmin.port = globalMin.portfolio(mu.vals, Sigma)\ngmin.port\n```\n\nPlot the frontier showing the global minimum variance portfolio with a negative weight in Asset A:\n\n```{r, echo=FALSE}\nrho.AB = 0.8\nsig.AB = rho.AB*sig.A*sig.B\n# create portfolios for frontier plot\nx.A = seq(from=-0.4, to=1.4, by=0.1)\nx.B = 1 - x.A\nn.port = length(x.A)\nnames(x.A) = names(x.B) = paste(\"p\", 1:n.port, sep=\".\")\nmu.p = x.A*mu.A + x.B*mu.B\nsig2.p = x.A^2 * sig2.A + x.B^2 * sig2.B + 2*x.A*x.B*sig.AB\nsig.p = sqrt(sig2.p)\nplot(sig.p, mu.p, type=\"b\", pch=16, cex = cex.val,\n     ylim=c(0, max(mu.p)), xlim=c(0, max(sig.p)),\n     xlab=expression(sigma[p]), ylab=expression(mu[p]), cex.lab=cex.val,\n     col=c(\"lightblue\", \"green\", rep(\"lightblue\", 2), rep(\"black\", 11), \n           rep(\"lightblue\", 4)))\ntext(x=sig.A, y=mu.A, labels=\"Asset A\", pos=4, cex = cex.val)\ntext(x=sig.B, y=mu.B, labels=\"Asset B\", pos=4, cex = cex.val)\ntext(gmin.port$sd, gmin.port$er, labels=\"Global Min\", pos = 4, \n     cex = cex.val)\n\n```\n\n## No short sales: T-Bills plus risky asset\n\n* Assume that investors can borrow and lend at risk-free rate \n* Investors cannot short risky asset\n* Portfolios of T-Bills and risky asset is not affected by no short sales constraint on risky asset\n\n```{r, echo=FALSE}\nr.f = 0.03\nx.A = seq(from=-1.4, to=1.4, by=0.1)\nmu.p.A = r.f + x.A*(mu.A - r.f)\nsig.p.A = abs(x.A)*sig.A\nplot(sig.p.A, mu.p.A, type=\"b\", ylim=c(min(mu.p.A), max(mu.p.A)),\n     xlim=c(-0.01, max(sig.p.A)), pch=16, cex = cex.val,\n     xlab=expression(sigma[p]), ylab=expression(mu[p]), cex.lab = cex.val,\n     col=c(rep(\"lightblue\", 14), rep(\"black\", 11), rep(\"lightblue\", 4)))\nabline(h=0)\ntext(x=sig.A, y=mu.A, labels=\"Asset A\", pos=4, cex = cex.val)\ntext(x=0, y=r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n```\n\n## 2 Risky assets plus T-bills\n\nFirst show case with rho = -0.164 with no shorts in global minimum variance portfolio and tangency portfolio\n\n```{r}\nrho.AB = -0.164\nsig.AB = rho.AB*sig.A*sig.B\nSigma = matrix(c(sig2.A, sig.AB, sig.AB, sig2.B), 2, 2)\nr.f = 0.03\ntan.port = tangency.portfolio(mu.vals, Sigma, r.f)\ntan.port\n```\n\n\n```{r, echo=FALSE}\n# risky asset only portfolios\nx.A = seq(from=0, to=1, by=0.1)\nx.B = 1 - x.A\nmu.p = x.A*mu.A + x.B*mu.B\nsig2.p = x.A^2 * sig2.A + x.B^2 * sig2.B + 2*x.A*x.B*sig.AB\nsig.p = sqrt(sig2.p)\n# T-bills plus tangency\nx.tan = seq(from=0, to=2.4, by=0.1)\nmu.p.tan.tbill = r.f + x.tan*(tan.port$er - r.f)\nsig.p.tan.tbill = x.tan*tan.port$sd\n# global minimum variance portfolio\ngmin.port = globalMin.portfolio(mu.vals, Sigma)\n# plot efficient portfolios\nplot(sig.p, mu.p, type=\"b\", pch=16, cex = cex.val,\n     ylim=c(0, 0.20), xlim=c(-0.01, 0.35),\n     xlab=expression(sigma[p]), ylab=expression(mu[p]), cex.lab = cex.val)\ntext(x=sig.A, y=mu.A, labels=\"Asset A\", pos=4, cex = cex.val)\ntext(x=sig.B, y=mu.B, labels=\"Asset B\", pos=4, cex = cex.val)\ntext(x=0, y=r.f, labels=expression(r[f]), pos=2, cex = cex.val)\ntext(x=tan.port$sd, y=tan.port$er, labels=\"Tangency\", pos=2, cex = cex.val)\ntext(gmin.port$sd, gmin.port$er, labels=\"Global Min\", pos = 4, \n     cex = cex.val)\npoints(sig.p.tan.tbill, mu.p.tan.tbill, type=\"l\", col=\"green\", \n       lwd=2, cex = cex.val)\n```\n\n## 2 Risky assets plus T-bills\n\nNext show case with rho = 0.8 with shorts in global minimum variance portfolio and tangency portfolio\n\n\n```{r}\nrho.AB = 0.7\nsig.AB = rho.AB*sig.A*sig.B\nSigma = matrix(c(sig2.A, sig.AB, sig.AB, sig2.B), 2, 2)\nr.f = 0.01\ntan.port = tangency.portfolio(mu.vals, Sigma, r.f)\nsummary(tan.port, r.f)\n```\n\n\n```{r, echo=FALSE}\nx.A = seq(from=-0.4, to=1.8, by=0.1)\nx.B = 1 - x.A\nmu.p = x.A*mu.A + x.B*mu.B\nsig2.p = x.A^2 * sig2.A + x.B^2 * sig2.B + 2*x.A*x.B*sig.AB\nsig.p = sqrt(sig2.p)\n# T-bills plus tangency\nx.tan = seq(from=0, to=2.4, by=0.1)\nmu.p.tan.tbill = r.f + x.tan*(tan.port$er - r.f)\nsig.p.tan.tbill = x.tan*tan.port$sd\n# global minimum variance portfolio\ngmin.port = globalMin.portfolio(mu.vals, Sigma)\nplot(sig.p, mu.p, type=\"b\", pch=16, cex = cex.val,\n     ylim=c(0, max(mu.p)), xlim=c(-0.01, max(sig.p)),\n     col=c(rep(\"lightblue\",4), rep(\"black\", 11), rep(\"lightblue\", 8)),\n     xlab=expression(sigma[p]), ylab=expression(mu[p]), cex.lab = cex.val)\ntext(x=sig.A, y=mu.A, labels=\"Asset A\", pos=4, cex = cex.val)\ntext(x=sig.B, y=mu.B, labels=\"Asset B\", pos=4, cex = cex.val)\ntext(gmin.port$sd, gmin.port$er, labels=\"Global Min\", pos = 4, \n     cex = cex.val)\ntext(x=0, y=r.f, labels=expression(r[f]), pos=2, cex = cex.val)\ntext(x=tan.port$sd, y=tan.port$er, labels=\"Tangency\", pos=2, cex = cex.val)\npoints(sig.p.tan.tbill, mu.p.tan.tbill, type=\"l\", col=\"green\", \n       lwd=2, cex = cex.val)\n```\n\nMax Sharpe ratio portfolio has 100% invested in asset A\n\n```{r}\n(mu.A - r.f)/sig.A\n```\n\n\n```{r}\nrho.AB = 0.7\nsig.AB = rho.AB*sig.A*sig.B\nSigma = matrix(c(sig2.A, sig.AB, sig.AB, sig2.B), 2, 2)\nr.f = 0.01\ntan.port = tangency.portfolio(mu.vals, Sigma, r.f, shorts=FALSE)\nsummary(tan.port, r.f)\n```\n\n## Three asset example data\n\nEstimates of CER model for Microsoft, Nordstrom and Starbucks stock from monthly returns over the period January 1995 to January 2000.\n\n```{r}\nasset.names <- c(\"MSFT\", \"NORD\", \"SBUX\")\nmu.vec = c(0.0427, 0.0015, 0.0285)\nnames(mu.vec) = asset.names\nsigma.mat = matrix(c(0.0100, 0.0018, 0.0011,\n\t\t   0.0018, 0.0109, 0.0026,\n\t\t   0.0011, 0.0026, 0.0199),\n\t\t nrow=3, ncol=3)\ndimnames(sigma.mat) = list(asset.names, asset.names)\nr.f = 0.005\nmu.vec\nsd.vec = sqrt(diag(sigma.mat))\ncov2cor(sigma.mat)\n```\n\n## Risk return characteristics\n\n```{r, echo=FALSE}\nplot(sd.vec, mu.vec,  ylim=c(0, 0.06), xlim=c(0, 0.20), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), pch=16, col=\"black\", cex=2.5, cex.lab=1.75)     \ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n\n```\n\n## Random portfolios: no short sales\n\n```{r}\nset.seed(123)\nx.msft = runif(400, min=0, max=1)\nx.nord = runif(400, min=0, max=1)\nx.sbux = 1 - x.msft - x.nord\nlong.only = which(x.msft > 0 & x.nord > 0 & x.sbux > 0)\nx.msft = x.msft[long.only]\nx.nord = x.nord[long.only]\nx.sbux = x.sbux[long.only]\nlength(long.only)\n```\n\n* Of the 400 generated random portfolios only `r length(long.only)` portfolios are long only.\n\n## Random portfolios: no short sales\n\n```{r}\n# plot portfolio weights\nchart.StackedBar(cbind(x.msft, x.nord, x.sbux), \n                 main=\"Random long-only portfolio weight vectors\",\n                 xlab = \"portfolio\", ylab = \"weights\",\n                 xaxis.labels=as.character(1:length(long.only)))\n```\n\n## Risk-return characteristics: long-only random portfolios\n\n```{r, echo=FALSE}\nplot(sd.vec, mu.vec,  ylim=c(0, 0.05), xlim=c(0, 0.2), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), type=\"n\")     \nfor (i in 1:length(long.only)) {\n  z.vec = c(x.msft[i], x.nord[i], x.sbux[i])\n  mu.p = crossprod(z.vec,mu.vec)\n  sig.p = sqrt(t(z.vec)%*%sigma.mat%*%z.vec)\n  points(sig.p, mu.p, pch=16, col=\"grey\", cex=1.5)\n}\npoints(sd.vec, mu.vec, pch=16, col=\"black\", cex=2.5, cex.lab=1.75)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\n```\n\n* With no short-sales allowed (long-only portfolios) the feasible set of portfolios shrinks dramatically.\n* Feasible set looks like an umbrella turned on its side.\n* Notice that it is not possible to find a no-short sales portfolio with a higher mean return than MSFT\n\n## Global minimum variance portfolio: no constraints on short sales\n\nUse the **IntroCompFinR** package function <code>globalMin.portfolio()</code>\n\n```{r}\ngmin.port = globalMin.portfolio(mu.vec, sigma.mat)\ngmin.port\n\n```\n\n* Global minimum variance portfolio without contraints on short sales does not have any negative weights (shorts)\n* Short sales constraint is not binding\n\n## Use the quadprog function <code>solve.QP()</code> to compute global minimum variance portfolio\n\nFirst we set up the appropriate restriction matrices required by the function <code>slove.QP()</code>\n\n```{r}\nD.mat = 2*sigma.mat\nd.vec = rep(0, 3)\nA.mat = cbind(rep(1,3), diag(3))\nb.vec = c(1, rep(0,3))\n```\n\n```{r}\nD.mat\n```\n\n```{r}\nd.vec\n```\n\n```{r}\nt(A.mat)\n```\n\n```{r}\nb.vec\n```\n\n## Use the quadprog function <code>solve.QP()</code> to compute global minimum variance portfolio\n\nThe function <code>solve.QP()</code> takes the restrictions matrices as inputs\n\n```{r}\nargs(solve.QP)\n```\n\n<code>solve.QP()</code> returns a list containing information about the optimization\n\n```{r}\nqp.out = solve.QP(Dmat=D.mat, dvec=d.vec,\n                  Amat=A.mat, bvec=b.vec, meq=1)\nclass(qp.out)\n```\n\nThe components of the returned list are\n\n```{r}\nnames(qp.out)\n```\n\nThe portfolio weights are in the <code>solution</code> component\n\n```{r}\nqp.out$solution\n```\n\nThe solution satisfies the required constraints (weights sum to one and all weights are positive)\n\n```{r}\nsum(qp.out$solution)\n```\n\nThe minimized value of the objective function (portfolio variance) is in the <code>value</code> component\n\n```{r}\nqp.out$value\n```\n\n## Use the quadprog function <code>solve.QP()</code> to compute global minimum variance portfolio\n\nCompute the mean and volatility of the minimum variance portfolio\n\n```{r}\n# Expected return\ner.gmin.ns = as.numeric(crossprod(qp.out$solution, mu.vec))\n# Volatility\nsd.gmin.ns = sqrt(qp.out$value)\n```\n\n```{r}\ner.gmin.ns\n```\n\n```{r}\nsd.gmin.ns\n```\n\n## Use the IntroCompFinR function <code>globalMin.Portfolio()</code> to compute the minimum variance portfolio\n\nUse the optional argument <code>shorts=TRUE</code> to impose no-short sales restrictions\n\n```{r}\nargs(globalMin.portfolio)\n```\n\nThe function sets up the restriction matrices for <code>solve.QP()</code> to compute the global minimum variance portfolio.\n\n```{r}\ngmin.port = globalMin.portfolio(mu.vec, sigma.mat,\n                                shorts=FALSE)\ngmin.port\n```\n\n* Notice that no assets are sold short in the unconstrained global minimum variance portfolio. Here the short sales constraint will not be binding.\n\n## Compute minimum variance portfolio with same mean as Microsoft\n\nFirst find the minimum variance portfolio allowing short sales\n\n```{r}\neMsft.port = efficient.portfolio(mu.vec, sigma.mat, target.return = mu.vec[\"MSFT\"])\neMsft.port\n```\n\n* Notice that NORD is sold short in the unconstrained minimum variance portfolio. Here the short sales constraint will be binding.\n\n## Compute minimum variance portfolio with same mean as Microsoft\n\nFirst we set up the appropriate restriction matrices required by the function <code>slove.QP()</code>\n\n```{r}\nD.mat = 2*sigma.mat\nd.vec = rep(0, 3)\nA.mat = cbind(mu.vec, rep(1,3), diag(3))\nb.vec = c(mu.vec[\"MSFT\"], 1, rep(0,3))\n```\n\n\n```{r}\nD.mat\n```\n\n```{r}\nd.vec\n```\n\n```{r}\nA.mat\n```\n\n```{r}\nb.vec\n```\n\n## Compute minimum variance portfolio with same mean as Microsoft\n\nNext we use <code>solve.QP()</code> to find the solution\n\n```{r}\nqp.out = solve.QP(Dmat=D.mat, dvec=d.vec,\n                  Amat=A.mat, bvec=b.vec, meq=2)\nnames(qp.out$solution) = names(mu.vec)\nround(qp.out$solution, digits=3)\n```\n\n* The argument <code>meq = 2</code> specifies 2 equality constraints. It tells <code>solve.QP()</code> how to determine $A_{eq}$ and $A_{neq}$ from $A$\n\n* Notice that the no-short sales solution forces the weights on Nordstrom and Starbucks to 0\n\n* It is not possible to find an no-short sale efficient portfolio that has a higher mean than Microsoft\n\n## Compute minimum variance portfolio with same mean as Microsoft\n\nThe **IntroCompFinR** function <code>efficient.portfolio()</code> with <code>shorts=FALSE</code> uses <code>solve.QP()</code> to compute a no-short sales efficient portfolio\n\n```{r}\nefficient.portfolio(mu.vec, sigma.mat, target.return = mu.vec[\"MSFT\"], shorts = FALSE)\n```\n\n\n## Infeasible no-short sale efficient portfolio\n\nSuppose you try to find an efficient portfolio with target return higher than the mean for Microsoft\n\n```{r}\n# efficient.portfolio(mu.vec, sigma.mat, target.return = mu.vec[\"MSFT\"]+0.01, shorts = FALSE)\n# Error in quadprog::solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec,  : \n#  constraints are inconsistent, no solution!\n```\n\n* Notice that <code>solve.QP()</code> throws an error saying there is no compatible solution\n\n## Compute efficient frontier allowing for short sales\n\nUse the **IntroCompFinR** function <code>efficient.frontier()</code> to compute the efficient set of frontier portfolios that allow short sales\n\n```{r}\nef = efficient.frontier(mu.vec, sigma.mat, alpha.min=0, \n                         alpha.max=1, nport=10)\nef$weights\n\n```\n\n* Notice that two efficient portfolios (Port 1 and Port 2) have negative weights (shorts)\n* Portfolio 10 is the global minimum variance portfolio\n\n## Plot efficient frontier allowing for short sales\n\n```{r, echo=FALSE}\nplot(ef$sd, ef$er, type=\"b\", ylim=c(0.02, 0.05), xlim=c(0.06, 0.11), \n     pch=16, col=\"lightblue\", cex=2, ylab=expression(mu[p]), xlab=expression(sigma[p]))\npoints(sd.vec, mu.vec, pch=16, col=\"black\", cex=2)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4)\ntext(ef$sd[10], ef$er[10], labels=\"port 10\", pos=4)\ntext(ef$sd[9], ef$er[9], labels=\"port 9\", pos=4)\n```\n\n* port 1 and port 2 have negative weights in Nordstrom\n\n## Compute efficient frontier without short sales\n\nIt is easy to compute the efficient frontier without short sales by running a simple loop\n\n```{r}\nmu.vals = seq(gmin.port$er, max(mu.vec), length.out=10)\nw.mat = matrix(0, length(mu.vals), 3)\nsd.vals = rep(0, length(sd.vec))\ncolnames(w.mat) = names(mu.vec)\nD.mat = 2*sigma.mat\nd.vec = rep(0, 3)\nA.mat = cbind(mu.vec, rep(1,3), diag(3))\nfor (i in 1:length(mu.vals)) {\n  b.vec = c(mu.vals[i],1,rep(0,3))\n  qp.out = solve.QP(Dmat=D.mat, dvec=d.vec,\n                    Amat=A.mat, bvec=b.vec, meq=2)\n  w.mat[i, ] = qp.out$solution\n  sd.vals[i] = sqrt(qp.out$value)\n}\n```\n\n## Compare frontiers\n\n```{r, echo=FALSE}\nplot(ef$sd, ef$er, type=\"b\", ylim=c(0.02, 0.05), xlim=c(0.06, 0.11), \n     pch=16, col=\"lightblue\", cex=2, ylab=expression(mu[p]), xlab=expression(sigma[p]))\npoints(sd.vec, mu.vec, pch=16, col=\"black\", cex=2)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4)\npoints(sd.vals, mu.vals, type=\"b\", pch=16, col=\"red\", cex=1.5)\ntext(ef$sd[10], ef$er[10], labels=\"port 10\", pos=2)\ntext(ef$sd[9], ef$er[9], labels=\"port 9\", pos=2)\n```\n\n* For portfolios 3 - 10, the no-short sales constraint is not binding and the two frontiers coinside. \n* Here, the no-short sales efficient frontier for Port 1 and Port 2 lies \"inside\" and \"to the right\" of the short sales allowed frontier\n\n## Compute efficient frontier without short sales\n\n```{r}\nef.ns = efficient.frontier(mu.vec, sigma.mat, alpha.min=0, \n                         alpha.max=1, nport=10, shorts=FALSE)\nef.ns$weights\n```\n\n* Note: There is a small bug in the `efficient.frontier()` code. When `shorts=FALSE` `alpha.min=0` starts at the global minimum variance portfolio so portfolios are listed in reverse order compared to when `shorts=TRUE`. \n\n## Copmpare efficient frontiers\n\n```{r}\nplot(ef$sd, ef$er, type=\"b\", ylim=c(0.001, 0.05), xlim=c(0.06, 0.15), \n     pch=16, col=\"lightblue\", cex=2, ylab=expression(mu[p]), xlab=expression(sigma[p]))\npoints(sd.vec, mu.vec, pch=16, col=\"black\", cex=2)\ntext(sd.vec, mu.vec, labels=asset.names, pos=3)\npoints(ef.ns$sd, ef.ns$er, type=\"b\", pch=16, col=\"red\")\ntext(ef$sd[10], ef$er[10], labels=\"port 10\", col=\"lightblue\", pos=2)\ntext(ef$sd[9], ef$er[9], labels=\"port 9\", col=\"lightblue\", pos=2)\ntext(ef.ns$sd[10], ef.ns$er[10], labels=\"port 10\", col=\"red\", pos=4)\ntext(ef.ns$sd[9], ef.ns$er[9], labels=\"port 9\", col=\"red\", pos=4)\n```\n\n* Here, Port 1 is the global minimum variance portfolio.\n\n## Unconstrained maximum Sharpe ratio (tangency) portfolio\n\nCompute maximum Sharpe ratio portfolio allowing short-sales:\n\n```{r}\nr.f = 0.005\ntan.port = tangency.portfolio(mu.vec, sigma.mat, r.f)\nsummary(tan.port, r.f)\n```\n\nShow efficient portfolios of T-Bills and tangency portfolio\n\n```{r}\nef = efficient.frontier(mu.vec, sigma.mat, alpha.min=-2, \n                        alpha.max=1.5, nport=20)\nplot(ef, plot.assets=TRUE, col=\"black\", pch=16)\n# points(gmin.port$sd, gmin.port$er, col=\"green\", pch=16, cex=2)\npoints(tan.port$sd, tan.port$er, col=\"red\", pch=16, cex=2)\nsr.tan = (tan.port$er - r.f)/tan.port$sd\nabline(a=r.f, b=sr.tan, col=\"green\", lwd=2)\ntext(tan.port$sd, tan.port$er, labels=\"Tangency\", pos = 2)\n```\n\n## Short-sales constrained maximum Sharpe ratio portfolio using `solve.QP()`\n\nThe restriction matrices are:\n\n```{r}\nD.mat = 2*sigma.mat\nd.vec = rep(0, 3)\nA.mat = cbind(mu.vec - rep(1, 3)*r.f, diag(3))\nb.vec = c(1, rep(0,3))\n```\n\nNext we use `solve.QP()` to find the solution\n\n```{r}\nqp.out = solve.QP(Dmat=D.mat, dvec=d.vec,\n                  Amat=A.mat, bvec=b.vec, meq=1)\nx.ns = qp.out$solution\nnames(x.ns) = names(mu.vec)\nround(x.ns, digits=3)\n```\n\nWe determine the short sales restricted tangency portfolio by normalizing the weights to sum to one:\n\n```{r}\nt.ns = x.ns/sum(x.ns)\nround(t.ns, digits=3)\n```\n\nCheck that result does not depend on value of target excess return > 0. Use 0.5 instead of 1.\n\n```{r}\nb.vec = c(0.5, rep(0,3))\nqp.out = solve.QP(Dmat=D.mat, dvec=d.vec,\n                  Amat=A.mat, bvec=b.vec, meq=1)\nx.ns = qp.out$solution\nnames(x.ns) = names(mu.vec)\nt.ns = x.ns/sum(x.ns)\nround(t.ns, digits=3)\n```\n\n## Short-sales constrained maximum Sharpe ratio portfolio using `tangency.portfolio()`\n\n```{r}\ntan.port.ns = tangency.portfolio(mu.vec, sigma.mat, r.f, shorts=FALSE)\nsummary(tan.port.ns, r.f)\n```\n\n```{r}\nef.ns = efficient.frontier(mu.vec, sigma.mat, alpha.min=0, \n                           alpha.max=1, nport=10, shorts=FALSE)\nplot(ef.ns, plot.assets=TRUE, pch=16)\n# points(gmin.port$sd, gmin.port$er, col=\"green\", pch=16, cex=2)\npoints(tan.port.ns$sd, tan.port.ns$er, col=\"red\", pch=16, cex=2)\nsr.tan.ns = (tan.port.ns$er - r.f)/tan.port.ns$sd\nabline(a=r.f, b=sr.tan.ns, col=\"green\", lwd=2)\ntext(tan.port$sd, tan.port$er, labels=\"Tangency\", pos = 2)\n```\n\n",
    "created" : 1474924971792.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1072640135",
    "id" : "3B5C9ECE",
    "lastKnownWriteTime" : 1474925616,
    "last_content_update" : 1474925616997,
    "path" : "C:/Users/ezivot/Dropbox/FinBook/R Presentations/portfolioTheoryNoShorts.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}