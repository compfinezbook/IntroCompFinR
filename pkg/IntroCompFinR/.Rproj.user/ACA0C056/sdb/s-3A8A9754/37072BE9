{
    "collab_server" : "",
    "contents" : "#' @title Compute efficient frontier of risky assets\n#' \n#' @author Eric Zivot\n#' \n#' @description\n#' The function constructs the set of mean-variance efficient portfolios that either allow all\n#' assets to be sold short or not allow any asset to be sold short. The returned object is of class\n#' \\samp{Markowitz} for which there are \\samp{print}, \\samp{summary} and \\samp{plot} methods.\n#' \n#' @details \n#' If short sales are allowed (negative weights) then the set of efficient portfolios of risky\n#' assets can be computed as a convex combination of any two efficient portfolios. It is convenient\n#' to use the global minimum variance portfolio as one portfolio and an efficient portfolio with\n#' target expected return equal to the maximum expected return of the assets under consideration as\n#' the other portfolio. Call these portfolios \\eqn{m} and \\eqn{x}, respectively. Then for any number\n#' \\samp{alpha}, another efficient portfolio can be computed as \\eqn{z=\\alpha m+(1-\\alpha)x}. If\n#' short sales are not allowed, then the set of efficient portfolios is computed by repeated calls\n#' to the function \\samp{efficient.portfolio()}, with \\samp{shorts=FALSE}, for a grid of target\n#' expected returns starting at the expected return of the global minimum variance portfolio (not\n#' allowing short sales) and ending at the expected return equal to the maximum expected return of \n#' the assets under consideration.\n#' \n#' @param er \\samp{N x 1} vector of expected returns\n#' @param cov.mat \\samp{N x N} return covariance matrix\n#' @param nport scalar, number of efficient portfolios to compute\n#' @param alpha.min minimum value of \\samp{alpha}, default is \\samp{-.5}\n#' @param alpha.max maximum value of \\samp{alpha}, default is \\samp{1.5}\n#' @param shorts logical, if \\samp{TRUE} then short sales (negative portfolio weights)\n#' are allowed. If \\samp{FALSE} then no asset is allowed to be sold short\n#' \n#' @return \n#'  \\item{call}{captures function call}\n#'  \\item{er}{\\samp{nport x 1} vector of expected returns of efficient porfolios}\n#'  \\item{sd}{\\samp{nport x 1} vector of standard deviations of efficient portfolios}\n#'  \\item{weights}{\\samp{nport x N} matrix of weights of efficient portfolios}\n#' \n#' @examples\n#' # construct the data\n#' asset.names = c(\"MSFT\", \"NORD\", \"SBUX\")\n#' er = c(0.0427, 0.0015, 0.0285)\n#' names(er) = asset.names\n#' covmat = matrix(c(0.0100, 0.0018, 0.0011,\n#'                   0.0018, 0.0109, 0.0026,\n#'                   0.0011, 0.0026, 0.0199),\n#'                 nrow=3, ncol=3)\n#' r.free = 0.005\n#' dimnames(covmat) = list(asset.names, asset.names)\n#' \n#' # tangency portfolio\n#' tan.port <- tangency.portfolio(er, covmat, r.free)\n#' # compute global minimum variance portfolio\n#' gmin.port = globalMin.portfolio(er, covmat)\n#' \n#' # compute portfolio frontier\n#' ef <- efficient.frontier(er, covmat, alpha.min=-2, \n#'                          alpha.max=1.5, nport=20)\n#' attributes(ef)\n#' \n#' plot(ef)\n#' plot(ef, plot.assets=TRUE, col=\"blue\", pch=16)\n#' points(gmin.port$sd, gmin.port$er, col=\"green\", pch=16, cex=2)\n#' points(tan.port$sd, tan.port$er, col=\"red\", pch=16, cex=2)\n#' text(gmin.port$sd, gmin.port$er, labels=\"GLOBAL MIN\", pos=2)\n#' text(tan.port$sd, tan.port$er, labels=\"TANGENCY\", pos=2)    \n#' sr.tan = (tan.port$er - r.free)/tan.port$sd\n#' abline(a=r.free, b=sr.tan, col=\"green\", lwd=2)\n#' \n#' @export efficient.frontier\n\nefficient.frontier <-\nfunction(er, cov.mat, nport=20, alpha.min=-0.5, alpha.max=1.5, shorts=TRUE)\n{\n  call <- match.call()\n\n  #\n  # check for valid inputs\n  #\n  asset.names <- names(er)\n  er <- as.vector(er)\n  N <- length(er)\n  cov.mat <- as.matrix(cov.mat)\n  if(N != nrow(cov.mat))\n    stop(\"invalid inputs\")\n  if(any(diag(chol(cov.mat)) <= 0))\n    stop(\"Covariance matrix not positive definite\")\n\n  #\n  # create portfolio names\n  #\n  port.names <- rep(\"port\",nport)\n  ns <- seq(1,nport)\n  port.names <- paste(port.names,ns)\n\n  #\n  # compute global minimum variance portfolio\n  #\n  cov.mat.inv <- solve(cov.mat)\n  one.vec <- rep(1, N)\n  port.gmin <- globalMin.portfolio(er, cov.mat, shorts)\n  w.gmin <- port.gmin$weights\n\n  if(shorts==TRUE){\n    # compute efficient frontier as convex combinations of two efficient portfolios\n    # 1st efficient port: global min var portfolio\n    # 2nd efficient port: min var port with ER = max of ER for all assets\n    er.max <- max(er)\n    port.max <- efficient.portfolio(er,cov.mat,er.max)\n    w.max <- port.max$weights    \n    a <- seq(from=alpha.min,to=alpha.max,length=nport) # convex combinations\n    we.mat <- (1-a) %o% w.gmin + a %o% w.max\t         # rows are efficient portfolios\n    er.e <- we.mat %*% er\t\t\t\t\t\t\t                 # expected returns of efficient portfolios\n    er.e <- as.vector(er.e)\n  } else if(shorts==FALSE){\n    we.mat <- matrix(0, nrow=nport, ncol=N)\n    we.mat[1,] <- w.gmin\n    we.mat[nport, which.max(er)] <- 1\n    er.e <- as.vector(seq(from=port.gmin$er, to=max(er), length=nport))\n    for(i in 2:(nport-1)) \n      we.mat[i,] <- efficient.portfolio(er, cov.mat, er.e[i], shorts)$weights\n  } else {\n    stop(\"shorts needs to be logical. For no-shorts, shorts=FALSE.\")\n  }\n  \n  names(er.e) <- port.names\n  cov.e <- we.mat %*% cov.mat %*% t(we.mat) # cov mat of efficient portfolios\n  sd.e <- sqrt(diag(cov.e))\t\t\t\t\t        # std devs of efficient portfolios\n  sd.e <- as.vector(sd.e)\n  names(sd.e) <- port.names\n  dimnames(we.mat) <- list(port.names,asset.names)\n\n  # \n  # summarize results\n  #\n  ans <- list(\"call\" = call,\n\t      \"er\" = er.e,\n\t      \"sd\" = sd.e,\n\t      \"weights\" = we.mat)\n  class(ans) <- \"Markowitz\"\n  ans\n}",
    "created" : 1473459461501.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "547111171",
    "id" : "37072BE9",
    "lastKnownWriteTime" : 1473459566,
    "last_content_update" : 1473459566106,
    "path" : "C:/Users/ezivot/Dropbox/FinBook/introcompfinr/pkg/IntroCompFinR/R/efficient.frontier.R",
    "project_path" : "R/efficient.frontier.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}