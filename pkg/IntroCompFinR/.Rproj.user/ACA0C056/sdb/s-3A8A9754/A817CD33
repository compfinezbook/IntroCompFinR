{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Portfolio Theory with Matrix Algebra\"\nauthor: \"Eric Zivot\"\ndate: \"August 6, 2015\"\noutput: slidy_presentation\n---\n\n## Set options and load packages\n\n```{r}\noptions(digits=3, width=70)\n# install IntroCompFinR package from R-forge\n# use install.packages(\"IntroCompFinR\", repos=\"http://R-Forge.R-project.org\")\nlibrary(IntroCompFinR)\nlibrary(PerformanceAnalytics)\nlibrary(zoo)\nSys.setenv(TZ=\"UTC\")\ncex.val = 2\n```\n\n## Three asset example data\n\nEstimates of CER model for Microsoft, Nordstrom and Starbucks stock from monthly returns over the period January 1995 to January 2000.\n\n```{r}\nasset.names <- c(\"MSFT\", \"NORD\", \"SBUX\")\nmu.vec = c(0.0427, 0.0015, 0.0285)\nnames(mu.vec) = asset.names\nsigma.mat = matrix(c(0.0100, 0.0018, 0.0011,\n\t\t   0.0018, 0.0109, 0.0026,\n\t\t   0.0011, 0.0026, 0.0199),\n\t\t nrow=3, ncol=3)\ndimnames(sigma.mat) = list(asset.names, asset.names)\nr.f = 0.005\nmu.vec\ncov2cor(sigma.mat)\n```\n\n## Risk return characteristics\n\n```{r, echo=FALSE}\nsd.vec = sqrt(diag(sigma.mat))\nplot(sd.vec, mu.vec,  ylim=c(0, 0.06), xlim=c(0, 0.20), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), pch=16, col=\"blue\", cex=2.5, cex.lab=1.75)     \ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n\n```\n\n* MSFT has highest Sharpe ratio\n* NORD has lowest Sharpe ratio\n\n## Example portfolio: equally weighted\n\n```{r}\n# create vector of portfolio weights\nx.vec = rep(1,3)/3\nnames(x.vec) = asset.names\n# compute mean, variance and volatility\nmu.p.x = crossprod(x.vec,mu.vec)\nsig2.p.x = t(x.vec)%*%sigma.mat%*%x.vec\nsig.p.x = sqrt(sig2.p.x)\n```\n\n```{r}\n# show mean and volatility\nmu.p.x\nsig.p.x\n\n```\n\n## Example portfolio: long-short\n\n```{r}\n# create vector of portfolio weights\ny.vec = c(0.8, 0.4, -0.2)\nnames(y.vec) = asset.names\n# compute mean, variance and volatility\nmu.p.y = crossprod(y.vec,mu.vec)\nsig2.p.y = t(y.vec)%*%sigma.mat%*%y.vec\nsig.p.y = sqrt(sig2.p.y)\n```\n\n```{r}\n# show mean and volatility\nmu.p.y\nsig.p.y\n```\n\n## Covariance and correlation between example portfolio returns\n\n```{r}\n# covariance\nsig.xy = t(x.vec)%*%sigma.mat%*%y.vec\nsig.xy\n```\n\n```{r}\n# correlation\nrho.xy = sig.xy/(sig.p.x*sig.p.y)\nrho.xy\n\n```\n\n## Risk-return characteristics: example portfolios\n\n```{r, echo=FALSE}\ncex.val = 1.15\nplot(sd.vec, mu.vec,  ylim=c(0, 0.06), xlim=c(0, 0.20), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), pch=16, col=\"blue\", cex=2.5, cex.lab=1.75)     \ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\npoints(sig.p.x, mu.p.x, pch=16, col=\"black\", cex=2.5)\ntext(sig.p.x, mu.p.x, labels=\"EQUAL WEIGHT\", pos=4, cex = cex.val)\npoints(sig.p.y, mu.p.y, pch=16, col=\"black\", cex=2.5)\ntext(sig.p.y, mu.p.y, labels=\"LONG-SHORT\", pos=4, cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n\n```\n\n## Risk-return characteristics: random portfolios\n\nCreate 200 random portfolio vectors with weights that sum to one.\n\n```{r}\nset.seed(123)\nx.msft = runif(200, min=-1.5, max=1.5)\nx.nord = runif(200, min=-1.5, max=1.5)\nx.sbux = 1 - x.msft - x.nord\nhead(cbind(x.msft, x.nord, x.sbux))\n```\n\n## Risk-return characteristics: random portfolios\n\n```{r}\n# plot portfolio weights\nchart.StackedBar(cbind(x.msft, x.nord, x.sbux), \n                 main=\"200 Random portfolio weight vectors\",\n                 xlab = \"portfolio\", ylab = \"weights\",\n                 xaxis.labels=as.character(1:200))\n```\n\n## Risk-return characteristics: random portfolios\n\n```{r, echo=FALSE}\nplot(sd.vec, mu.vec,  ylim=c(-0.03, 0.09), xlim=c(0, 0.4), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), type=\"n\")     \nfor (i in 1:length(x.msft)) {\n  z.vec = c(x.msft[i], x.nord[i], x.sbux[i])\n  mu.p = crossprod(z.vec,mu.vec)\n  sig.p = sqrt(t(z.vec)%*%sigma.mat%*%z.vec)\n  points(sig.p, mu.p, pch=16, col=\"grey\", cex=1.5)\n}\npoints(sd.vec, mu.vec, pch=16, col=\"blue\", cex=2.5, cex.lab=1.75)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\n```\n\n* With more than two assets, set of feasible portfolios is no longer one side of a hyperbole\n* Set of feasible portfolios is a solid space\n* Efficient portfolios are on the upper boundary (above minimimum variance portfolio)\n\n## Compute global minimum variance portfolio: Method 1\n\nUse $z_m = A^{-1}_m b$.\n\n```{r}\ntop.mat = cbind(2*sigma.mat, rep(1, 3))\nbot.vec = c(rep(1, 3), 0)\nAm.mat = rbind(top.mat, bot.vec)\nb.vec = c(rep(0, 3), 1)\nz.m.mat = solve(Am.mat)%*%b.vec\nm.vec = z.m.mat[1:3,1]\n# minimum variance portfolio weights\nm.vec\n```\n\nMean and volatility of minimum variance portfolio\n\n```{r}\nmu.gmin = as.numeric(crossprod(m.vec, mu.vec))\nsig2.gmin = as.numeric(t(m.vec)%*%sigma.mat%*%m.vec)\nsig.gmin = sqrt(sig2.gmin)\nmu.gmin\nsig.gmin\n```\n\n## Compute global minimum variance portfolio: Method 2\n\nUse analytic formula for minimum variance portfolio\n\n```{r}\none.vec = rep(1, 3)\nsigma.inv.mat = solve(sigma.mat)\ntop.mat = sigma.inv.mat%*%one.vec\nbot.val = as.numeric((t(one.vec)%*%sigma.inv.mat%*%one.vec))\nm.mat = top.mat/bot.val\nm.mat[, 1]\n\n```\n\n## Show minimum variance portfolio \n\n```{r, echo=FALSE}\nplot(sd.vec, mu.vec,  ylim=c(-0.03, 0.09), xlim=c(0, 0.4), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), type=\"n\")     \ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\nfor (i in 1:length(x.msft)) {\n  z.vec = c(x.msft[i], x.nord[i], x.sbux[i])\n  mu.p = crossprod(z.vec,mu.vec)\n  sig.p = sqrt(t(z.vec)%*%sigma.mat%*%z.vec)\n  points(sig.p, mu.p, pch=16, col=\"grey\", cex=1.5)\n}\npoints(sd.vec, mu.vec, pch=16, col=\"blue\", cex=2.5, cex.lab=1.75)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\npoints(sig.gmin, mu.gmin, pch=16, cex=2.5, col=\"green\")\ntext(sig.gmin, mu.gmin, labels=\"GLOBAL MIN\", pos=2.5, cex = cex.val)\n```\n\n* If there is \"justice in the world\" then the mean and volatility of the global minimum variance portfolio will plot at the tip of the Markowitz bullet.\n* It does!\n\n## Compute efficient portfolio with the same mean as Microsoft\n\nUse matrix algebra formula to compute efficient portfolio.\n\n```{r}\ntop.mat = cbind(2*sigma.mat, mu.vec, rep(1, 3))\nmid.vec = c(mu.vec, 0, 0)\nbot.vec = c(rep(1, 3), 0, 0)\nAx.mat = rbind(top.mat, mid.vec, bot.vec)\nbmsft.vec = c(rep(0, 3), mu.vec[\"MSFT\"], 1)\nz.mat = solve(Ax.mat)%*%bmsft.vec\nx.vec = z.mat[1:3,]\nx.vec\n```\n\nCompute mean and volatility of efficient portfolio.\n\n```{r}\nmu.px = as.numeric(crossprod(x.vec, mu.vec))\nsig2.px = as.numeric(t(x.vec)%*%sigma.mat%*%x.vec)\nsig.px = sqrt(sig2.px)\nmu.px\nsig.px\n```\n\nCompare with mean and volatility of Microsoft.\n\n```{r}\nmu.vec[\"MSFT\"]\nsd.vec[\"MSFT\"]\n```\n\n* Efficient portfolio has slightly smaller volatility than Microsoft.\n* Microsoft is near the efficient frontier boundary\n\n## Compute efficient portfolio with the same mean as Starbucks\n\n```{r}\n# solve for portfolio weights\nbsbux.vec = c(rep(0, 3), mu.vec[\"SBUX\"], 1)\nz.mat = solve(Ax.mat)%*%bsbux.vec\ny.vec = z.mat[1:3,]\ny.vec\n```\n\n```{r}\n# compute mean, variance and std deviation\nmu.py = as.numeric(crossprod(y.vec, mu.vec))\nsig2.py = as.numeric(t(y.vec)%*%sigma.mat%*%y.vec)\nsig.py = sqrt(sig2.py)\nmu.py\nsig.py\n```\n\n```{r}\n# compare with Starbucks\nmu.vec[\"SBUX\"]\nsd.vec[\"SBUX\"]\n```\n\n* Efficient portfolio has much smaller volatility than Starbucks!\n* Starbucks is far away from the efficient frontier boundary\n\n## Covariance between efficient portfolio returns\n\nLater on, we will use the covariance between the two efficient portfolios.\n\n```{r}\nsigma.xy = as.numeric(t(x.vec)%*%sigma.mat%*%y.vec)\nrho.xy = sigma.xy/(sig.px*sig.py)\nsigma.xy\nrho.xy\n```\n\n## Show efficient portfolios\n\n```{r, echo=FALSE}\nsd.vec = sqrt(diag(sigma.mat))\nplot(sd.vec, mu.vec,  ylim=c(0, 0.06), xlim=c(0, 0.20), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), pch=16, col=\"blue\", cex=2)\npoints(sig.gmin, mu.gmin, pch=16, cex=2, col=\"green\")\npoints(sig.px, mu.px, pch=16, cex=2, col=\"green\")\npoints(sig.py, mu.py, pch=16, cex=2, col=\"green\")      \ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\ntext(sig.gmin, mu.gmin, labels=\"GLOBAL MIN\", pos=2, cex = cex.val)        \ntext(sig.px, mu.px, labels=\"E1\", pos=2, cex = cex.val) \ntext(sig.py, mu.py, labels=\"E2\", pos=2, cex = cex.val) \ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n\n```\n\n* Point E1 is the efficient portfolio with the same mean as Microsoft\n* Point E2 is the efficient portfolio withe the same mean as Starbucks\n\n## Find efficient portfolio from two efficient portfolios\n\nHere we use the fact that any efficient portfolio is a convex combination of any two efficient portfolios: \n\n$$z = \\alpha \\times x + (1 - \\alpha) \\times y$$\n\nSet $\\alpha = 0.5$.\n\n```{r}\na = 0.5\nz.vec = a*x.vec + (1-a)*y.vec\nz.vec\n```\n\nCompute the mean and volatility.\n\n```{r}\nsigma.xy = as.numeric(t(x.vec)%*%sigma.mat%*%y.vec)\nmu.pz = as.numeric(crossprod(z.vec, mu.vec))\nsig2.pz = as.numeric(t(z.vec)%*%sigma.mat%*%z.vec)\nsig.pz = sqrt(sig2.pz)\nmu.pz\nsig.pz\n```\n\nHere the mean is half-way between the mean of Microsoft and the mean of Starbucks.\n\n## Compute efficient portfolio with mean 0.05\n\nGiven a target mean value, $\\mu_0 = 0.05$, you can solve for $\\alpha$.\n\n```{r}\na.05 = (0.05 - mu.py)/(mu.px - mu.py)\na.05\n```\n\nGiven $\\alpha=$ `r a.05` solve for $z$.\n\n```{r}\nz.05 = a.05*x.vec + (1 - a.05)*y.vec\nz.05\n```\n\nFinally, compute the mean and volatility.\n\n```{r}\nmu.pz.05 = as.numeric(crossprod(z.05,mu.vec))\nsig.pz.05 = as.numeric(sqrt(t(z.05)%*%sigma.mat%*%z.05))\nmu.pz.05\nsig.pz.05\n```\n\n## Compute frontier portfolio with same mean as Nordstrom\n\n```{r}\n# compute alpha\na.nord = (mu.vec[\"NORD\"] - mu.py)/(mu.px - mu.py)\na.nord\n# compute weights\nz.nord = a.nord*x.vec + (1 - a.nord)*y.vec\nz.nord\n# compute mean and volatility\nmu.pz.nord = as.numeric(crossprod(z.nord,mu.vec))\nsig.pz.nord = as.numeric(sqrt(t(z.nord)%*%sigma.mat%*%z.nord))\nmu.pz.nord\nsig.pz.nord  \n```\n\n\n## Show frontier portfolios\n\n```{r, echo=FALSE}\nsd.vals = c(sig.px, sig.py, sig.pz, sig.pz.05)\nmu.vals = c(mu.px, mu.py, mu.pz, mu.pz.05)\nplot(sd.vals, mu.vals,  ylim=c(0, 0.06), xlim=c(0, 0.20), ylab=expression(mu[p]),\n     xlab=expression(sigma[p]), pch=16, col=\"green\", cex=2) \npoints(sig.gmin, mu.gmin, pch=16, cex=2, col=\"green\")     \npoints(sd.vec, mu.vec, pch=16, col=\"blue\", cex=2)\npoints(sig.pz.nord, mu.pz.nord, pch=16, col=\"red\", cex=2)\ntext(sd.vals, mu.vals, labels=c(\"E1\",\"E2\",\"E3\",\"E4\"), pos=2, cex = cex.val)\ntext(sig.gmin, mu.gmin, labels=\"GLOBAL MIN\", pos=2, cex = cex.val)        \ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\ntext(sig.pz.nord, mu.pz.nord, labels=\"IE1\", pos=2, cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n```\n\n* Point E1 is the efficient portfolio with the same mean as Microsoft\n* Point E2 is the efficient portfolio with the same mean as Starbucks\n* Point E3 is the efficient portfolio with $\\alpha = 0.5$\n* Point E4 is the efficient portfolio with $\\alpha=$ `r a.05`.\n\n## Compute efficient frontier\n\nHere we compute efficient portfolios as convex combinations of the the global minimum variance portfolio and the efficient portfolio with the same mean as Microsoft.\n\n```{r}\na = seq(from=0, to=1, by=0.1)\nn.a = length(a)\nz.mat = matrix(0, n.a, 3)\ncolnames(z.mat) = names(mu.vec)\nmu.z = rep(0, n.a)\nsig2.z = rep(0, n.a)\nsig.mx = t(m.vec)%*%sigma.mat%*%x.vec\nfor (i in 1:n.a) {\n  z.mat[i, ] = a[i]*x.vec + (1-a[i])*m.vec\n  mu.z[i] = a[i]*mu.px + (1-a[i])*mu.gmin\n  sig2.z[i] = a[i]^2 * sig2.px + (1-a[i])^2 * sig2.gmin + 2*a[i]*(1-a[i])*sig.mx\n}\n\n```\n\n## Show efficient frontier\n\n```{r, echo=FALSE}\nplot(sqrt(sig2.z), mu.z, type=\"b\", ylim=c(0, 0.06), xlim=c(0, 0.16), \n     pch=16, col=\"green\", cex = cex.val, ylab=expression(mu[p]), xlab=expression(sigma[p]))\npoints(sd.vec, mu.vec, pch=16, cex=2, lwd=2, col=\"blue\")\npoints(sig.gmin, mu.gmin, pch=16, col=\"black\", cex=2)\npoints(sig.px, mu.px, pch=16, col=\"black\", cex=2)\ntext(sig.gmin, mu.gmin, labels=\"GLOBAL MIN\", pos=2, cex = cex.val)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex = cex.val)\ntext(sig.px, mu.px, labels=\"E1\", pos=2, cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n```\n\n## show weights in efficient portfolios\n\n```{r}\nchart.StackedBar(z.mat, xaxis.labels=round(sqrt(sig2.z),digits=3), \n                 xlab=\"Portfolio SD\", ylab=\"Weights\")\n```\n\n* The x-axis shows the volatility of each efficient portfolio\n* The first portfolio is the global minimum variance portfolio\n* Notice that Nordstrom eventually gets shorted in the efficient portfolios with high volatility and high expected return\n\n## Show efficient frontier with random portfolios\n\n```{r, echo=FALSE}\na = seq(from=1, to=-2, by=-0.1)\nn.a = length(a)\nz.mat = matrix(0, n.a, 3)\nmu.z = rep(0, n.a)\nsig2.z = rep(0, n.a)\nsig.mx = t(m.vec)%*%sigma.mat%*%x.vec\nfor (i in 1:n.a) {\n  z.mat[i, ] = a[i]*m.vec + (1-a[i])*x.vec\n  mu.z[i] = a[i]*mu.gmin + (1-a[i])*mu.px\n  sig2.z[i] = a[i]^2 * sig2.gmin + (1-a[i])^2 * sig2.px + 2*a[i]*(1-a[i])*sig.mx\n}\n\nplot(sqrt(sig2.z), mu.z, type=\"n\", ylim=c(-0.03, 0.09), xlim=c(0, 0.4), \n     ylab=expression(mu[p]), xlab=expression(sigma[p]))\n\nfor (i in 1:length(x.msft)) {\n  z.vec = c(x.msft[i], x.nord[i], x.sbux[i])\n  mu.p = crossprod(z.vec,mu.vec)\n  sig.p = sqrt(t(z.vec)%*%sigma.mat%*%z.vec)\n  points(sig.p, mu.p, pch=16, col=\"grey\", cex=1.5)\n}\npoints(sqrt(sig2.z), mu.z, type=\"b\", pch=16, col=\"green\", cex = cex.val)\npoints(sd.vec, mu.vec, pch=16, cex=2, col=\"blue\")\ntext(sig.gmin, mu.gmin, labels=\"GLOBAL MIN\", pos=2, col=\"black\", cex = cex.val)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, col=\"blue\", cex = cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex = cex.val)\n\n```\n\n## Compute tangency (maximum Sharpe ratio) portfolio\n\nHere we use the analytic matrix albegra formula for the tangency portfolio.\n\n```{r}\nrf = 0.005\nsigma.inv.mat = solve(sigma.mat)\none.vec = rep(1, 3)\nmu.minus.rf = mu.vec - rf*one.vec\ntop.mat = sigma.inv.mat%*%mu.minus.rf\nbot.val = as.numeric(t(one.vec)%*%top.mat)\nt.vec = top.mat[,1]/bot.val\nt.vec\n```\n\nCompute mean and volatility of tangency portfolio\n\n```{r}\nmu.t = as.numeric(crossprod(t.vec, mu.vec))\nsig2.t = as.numeric(t(t.vec)%*%sigma.mat%*%t.vec)\nsig.t = sqrt(sig2.t)\nmu.t\nsig.t\n```\n\nCompute Sharpe ratio of tangency portfolio\n\n```{r}\nSR.t = (mu.t - r.f)/sig.t\nSR.t\n```\n\n## Show efficient portfolios when there is a risk free asset\n\nEfficient portfolios are combinations of T-Bills and the tangency portfolio.\n\n```{r, echo=FALSE}\nx.t = seq(0, 2, by=0.1)\nmu.pe = r.f + x.t*(mu.t - r.f)\nsig.pe = x.t*sig.t \nslope.t = (mu.t - r.f)/sig.t\n\na = seq(from=0, to=2, by=0.1) \nn.a = length(a) \nz.mat = matrix(0, n.a, 3) \ncolnames(z.mat) = names(mu.vec) \nmu.z = rep(0, n.a) \nsig2.z = rep(0, n.a) \nsig.mx = t(m.vec)%*%sigma.mat%*%x.vec \nfor (i in 1:n.a) {   \n   z.mat[i, ] = a[i]*x.vec + (1-a[i])*m.vec   \n   mu.z[i] = a[i]*mu.px + (1-a[i])*mu.gmin   \n   sig2.z[i] = a[i]^2 * sig2.px + (1-a[i])^2 * sig2.gmin + 2*a[i]*(1-a[i])*sig.mx \n}\n# plot efficient portfolios\nplot(sqrt(sig2.z), mu.z, type=\"b\", ylim=c(0, 0.08), xlim=c(0, 0.17), \n     pch=16, col=\"blue\", cex=1.15, ylab=expression(mu[p]), xlab=expression(sigma[p]))\nabline(a=r.f, b=slope.t, col=\"green\", lwd=2)\npoints(sig.t, mu.t, pch=16, col=\"green\", cex=1.15)\npoints(sd.vec, mu.vec, pch=16, cex=2, col=\"black\")\ntext(sig.gmin, mu.gmin, labels=\"Global min\", pos=4, cex=1.15)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex=1.15)\ntext(sig.t, mu.t, labels=\"tangency\", pos=4,cex=1.15)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex=1.15)\n\n```\n\n## Show efficient portfolio weights\n\n```{r, echo=FALSE}\nt.mat = x.t %o% t.vec\ne.mat = cbind(1-x.t, t.mat)\ncolnames(e.mat)[1] = \"T-Bill\"\nchart.StackedBar(e.mat, xaxis.labels=round(sig.pe,digits=3), \n                 xlab=\"Portfolio SD\", ylab=\"Weights\")\n\n```\n\n## Find efficient portfolio with a target volatility\n\nEvery efficient portfolio is a combination of T-bills and the tangency portfolio. The volatility of such an efficient portfolio is: \n\n$$ \\sigma_e = x_{tan} \\times \\sigma_{tan} $$\n\nGiven a target volatility, $\\sigma_0 = 0.02$, you can solve for $x_{tan}$ and $x_f = 1 - x_{tan}$: \n\n```{r}\nx.t.02 = 0.02/sig.t\nx.t.02\n1-x.t.02\n\n```\n\nThe efficient portfolio weights in MSFT, NORD, SBUX are:\n\n```{r}\nx.t.02*t.vec\n```\n\nThe mean and volatility of this efficient portfolio are:\n\n```{r}\nmu.t.02 = x.t.02*mu.t + (1-x.t.02)*r.f\nsig.t.02 = x.t.02*sig.t\nmu.t.02\nsig.t.02\n\n```\n\n## Find efficient portfolio with a target expected return\n\nEvery efficient portfolio is a combination of T-bills and the tangency portfolio. The mean of such an efficient portfolio is: \n\n$$ \\mu_e = r_f + x_{tan} \\times (\\mu_{tan} - r_f) $$\n\nGiven a target mean, $\\mu_0 = 0.07$, you can solve for $x_{tan}$ and $x_f = 1 - x_{tan}$: \n\n```{r}\nx.t.07 = (0.07 - rf)/(mu.t - r.f)\nx.t.07\n1-x.t.07\n```\n\nThe efficient portfolio weights in MSFT, NORD, SBUX are:\n\n```{r}\nx.t.07*t.vec\n\n```\n\nThe mean and volatility of this efficient portfolio are:\n\n```{r}\nmu.t.07 = x.t.07*mu.t + (1-x.t.07)*r.f\nsig.t.07 = x.t.07*sig.t\nmu.t.07\nsig.t.07\n\n```\n\n## Show efficient portfolios with target mean and target volatility\n\n```{r, echo=FALSE}\nplot(sqrt(sig2.z), mu.z, type=\"b\", ylim=c(0, 0.08), xlim=c(0, 0.17), \n     pch=16, col=\"blue\", cex=cex.val, ylab=expression(mu[p]), xlab=expression(sigma[p]))\nabline(a=r.f, b=slope.t, col=\"green\", lwd=2)\npoints(sig.t, mu.t, pch=16, col=\"green\", cex=2)\npoints(sig.t.02, mu.t.02, pch=16, col=\"green\", cex=2)\npoints(sig.t.07, mu.t.07, pch=16, col=\"green\", cex=2)\npoints(sd.vec, mu.vec, pch=16, col=\"black\", cex=cex.val)\ntext(sig.gmin, mu.gmin, labels=\"Global min\", pos=4, cex=cex.val)\ntext(sd.vec, mu.vec, labels=asset.names, pos=4, cex=cex.val)\ntext(sig.t, mu.t, labels=\"tangency\", pos=4, cex=cex.val)\ntext(sig.t.02, mu.t.02, labels=\"E1\", pos=3, cex=cex.val)\ntext(sig.t.07, mu.t.07, labels=\"E2\", pos=3, cex=cex.val)\ntext(0, r.f, labels=expression(r[f]), pos=2, cex=cex.val)\n\nsegments(0.02, 0, 0.02, mu.t.02, col=\"green\", lty=\"dashed\", lwd=2)\ntext(0.02, 0, labels=\"0.02\", col=\"black\", lwd=2, pos=3)\nsegments(0, mu.t.07, sig.t.07, mu.t.07, col=\"green\", lty=\"dashed\", lwd=2)\ntext(0, 0.07, labels=\"0.07\", col=\"black\", lwd=2, pos=4)\n\n```\n\n* Point E1 is the efficient portfolio with a target volatility $\\sigma_0 = 0.02$.\n* Point E2 is the efficient portfolio with a target mean $\\mu_0 = 0.07$.\n\n## Computational problems with very large portfolios\n\n* Problem: sample covariance matrix is not full rank when N > T\n* Illustrate problem using monthly returns on 6 Vanguard mutual funds\n\n```{r}\ndata(VanguardPrices)\nVanguardPrices = as.xts(VanguardPrices)\ncolnames(VanguardPrices)\nrange(index(VanguardPrices))\nVanguardRetS = na.omit(Return.calculate(VanguardPrices, method=\"simple\"))\n```\n\nCompute sample covariance of 6 assets using 5 observations\n\n```{r}\ncovhat = cov(VanguardRetS[1:5, ])\nchol(covhat)\nsolve(covhat)\n```\n\n\n## Portfolio functions in IntroCompFinR\n\nThe package **IntroCompFinR** contains a few R functions for computing Markowitz mean-variance efficient portfolios allowing for short sales using matrix algebra computations. These functions allow for the easy computation of the global minimum variance portfolio, an efficient portfolio with a given target expected return, the tangency portfolio, and the efficient frontier. These functions are summarized below:\n\n* `getPortfolio()`:  create \"`portfolio`\" object\n* `globalMin.portfolio()`: compute global minimum variance portfolio\n* `efficient.portfolio()` compute minimum variance portfolio subject to target return\n* `tangency.portfolio()` compute tangency portfolio\n* `efficient.frontier()` compute efficient frontier of risky assets\n\n## Example data (same as before)\n\n```{r}\nmu.vec\nsigma.mat\nr.f\n```\n\n## Create \"`portfolio`\" object with `getPortfolio()`\n\nCreate equally weighted portfolio object:\n\n```{r}\nlibrary(IntroCompFinR)\new = rep(1,3)/3\nequalWeight.portfolio = getPortfolio(er=mu.vec,cov.mat=sigma.mat,weights=ew)\nclass(equalWeight.portfolio)\n```\n\n\"`portfolio`\" objects have the following components:\n\n```{r}\nnames(equalWeight.portfolio)\n```\n\n## Method functions for \"`portfolio`\" objects\n\nThere are `print()`, `summary()` and `plot()` methods for \"`portfolio`\" objects. The `print()` method gives:\n\n```{r}\nequalWeight.portfolio\n```\n\nThe `plot()` method shows a bar chart of the portfolio weights:\n\n```{r}\nplot(equalWeight.portfolio, col=\"cornflowerblue\")\n```\n\n## Compute global minimum variance portfolio with `globalMin.portfolio()`\n\nTo compute the global minimum variance portfolio use the function `globalMin.portfolio()`:\n\n```{r}\ngmin.port = globalMin.portfolio(mu.vec, sigma.mat)\nclass(gmin.port)\ngmin.port\n```\n\n## Compute minimum variance portfolio subject to target return using `efficient.portfolio()`\n\nUse the `efficient.portfolio()` function to compute a mean-variance efficient portfolio with the same mean as MSFT:\n\n```{r}\ntarget.return = mu.vec[1]\ne.port.msft = efficient.portfolio(mu.vec, sigma.mat, target.return)\nclass(e.port.msft)\ne.port.msft\n```\n\n## Compute tangency portfolio using `tangent.portfolio()`\n\nTo compute the tangency portfolio with $r_{f}=0.005$ use the `tangency.portfolio()` function:\n\n```{r}\ntan.port = tangency.portfolio(mu.vec, sigma.mat, r.f)\nclass(tan.port)\ntan.port\n```\n\n## Compute efficient frontier using `efficient.frontier()`\n\nThe function `efficient.frontier()` constructs the set of efficient portfolios using this method for a collection of $\\alpha$ values on an equally spaced grid between $\\alpha_{min}$ and $\\alpha_{max}$. For example, to compute 20 efficient portfolios for values of $\\alpha$ between -2 and 1.5 use:\n\n```{r}\nef = efficient.frontier(mu.vec, sigma.mat, alpha.min=-0.5, \n                        alpha.max=2, nport=20)\nattributes(ef)\nef\n```\n\nUse the `summary()` method to show the weights of these portfolios:\n\n```{r}\nsummary(ef)\n```\n\nUse the `plot()` method to create a simple plot the efficient frontier:\n\n```{r}\nplot(ef)\n```\n\n## Plot the efficient frontier\n\nTo create a more elaborate plot of the efficient frontier showing the original assets and the tangency portfolio use:\n\n```{r}\nplot(ef, plot.assets=T, col=\"blue\", pch=16)\npoints(gmin.port$sd, gmin.port$er, col=\"green\", pch=16, cex=2)\ntext(gmin.port$sd, gmin.port$er, labels = \"Global min\", pos = 4)\npoints(tan.port$sd, tan.port$er, col=\"red\", pch=16, cex=2)\ntext(tan.port$sd, tan.port$er, labels = \"Tangency\", pos = 3)\nsr.tan = (tan.port$er - r.f)/tan.port$sd\nabline(a=r.f, b=sr.tan, col=\"green\", lwd=2)\n```\n\n",
    "created" : 1474918085672.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2746968314",
    "id" : "A817CD33",
    "lastKnownWriteTime" : 1470440966,
    "last_content_update" : 1474922577224,
    "path" : "C:/Users/ezivot/Dropbox/FinBook/R Presentations/portfolioTheoryMatrix.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}